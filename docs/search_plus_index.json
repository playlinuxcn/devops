{"./":{"url":"./","title":"介绍","keywords":"","body":"Introduction powered by Gitbook该文章修订时间： 2021-02-18 10:39:49 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"base/linux-base/00-Linux中的回车与换行.html":{"url":"base/linux-base/00-Linux中的回车与换行.html","title":"00-Linux中的回车与换行","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 一、\"回车\"（carriage return）和\"换行\"（line feed）的来历和区别 二、Linux中查看文件的换行符： 三、Mac/Windows文本在 Linux 下的转换 四、base64编码解码 一、\"回车\"（carriage return）和\"换行\"（line feed）的来历和区别 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打 10 个字符。 但是它有一个问题，就是打完一行换行的时候，要用去 0.2 秒，正好可以打两个字符。要是在这 0.2 秒里面，又有新的字符传过来，那么这个字符将丢失。 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。 一个叫做\"回车\"，告诉打字机把打印头定位在左边界； 另一个叫做\"换行\"，告诉打字机把纸向下移一行。 这就是\"换行\"和\"回车\"的来历，从它们的英语名字上也可以看出一二。 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。 Unix系统里，每行结尾只有\"\"，即\"\\n\"； Windows系统里面，每行结尾是\"\"，即\"\\r\\n\"； Mac系统里，每行结尾是\"\"。 一个直接后果是，Unix/Mac 系统下的文件在Windows里打开的话，所有文字会变成一行； 而 Windows 里的文件在 Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号,这多出来的 \\r 被vim解释成了^M。 二、Linux中查看文件的换行符： 1、vim filename (:set list) 2、cat -T filenae 显示TAB键的字符^I 3、cat -E filename 显示行尾的结束字符$ 4、cat -A filename 显示所有不可见的字符 三、Mac/Windows文本在 Linux 下的转换 解决的问题： 1、Windows下编写的 SH 脚本，放到 Linux下执行可能会出错。 2、Linux下新建的文档在Windows下用记事本打开内容会挤在一起（没有了换行符）。原因是记事本不支持\\n换行（它只支持\\r\\n形式的换行） 1、dos2unix/mac2unix filename 2、sed 's/^M//' filename > tmp_filename 3、vim 命令行模式下 :set fileformat=unix :set fileformat=dos :set fileformat=mac 四、base64编码解码 ➜ ~ echo 123|base64 MTIzCg== ➜ ~ echo -n 123|base64 MTIz ➜ ~ 使用 echo 输出字符串时，如果没有 -n 参数会自动添加换行符，这会令 base64 编码出来的结果不符合预期。 比如在 k8s 中做 secret 的时候，添加加密变量的时候，如果没有使用 -n 去除换行符，在容器中便不能正常解码。 powered by Gitbook该文章修订时间： 2021-02-25 10:45:35 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"base/linux-base/01-字符集与字符编码.html":{"url":"base/linux-base/01-字符集与字符编码.html","title":"01-字符集与字符编码","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 一、相关概念的理解 0、字符/字节/字符串 1、什么是字符集 2、什么是字符编码 3、ASCII 码 4、非ASCII 码 5、Unicode 6、Unicode 的问题 7、UTF-8 二、容易产生的误解 三、乱码产生的原因和解决办法 第1步 编码 第2步 识别 第3步 解码 四、字符编码工作方式 五、常见问题处理之Emoji “字符与编码”是一个被经常讨论的话题。即使这样，时常出现的乱码仍然困扰着大家。虽然我们有很多的办法可以用来消除乱码，但我们并不一定理解这些办法的内在原理。而有的乱码产生的原因，实际上由于底层代码本身有问题所导致的。因此，不仅是初学者会对字符编码感到模糊，有的底层开发人员同样对字符编码缺乏准确的理解。 一、相关概念的理解 0、字符/字节/字符串 概念描述 举例 字符 人们使用的记号，抽象意义上的一个符号。 '1', '中', 'a', '$', '￥', …… 字节 计算机中存储数据的单元，一个8位的二进制数，是一个很具体的存储空间。 0x01, 0x45, 0xFA, …… ANSI 字符串 在内存中，如果“字符”是以 ANSI 编码形式存在的，一个字符可能使用一个字节或多个字节来表示，那么我们称这种字符串为 ANSI 字符串或者多字节字符串。 \"中文123\" （占7字节） UNICODE 字符串 在内存中，如果“字符”是以在 UNICODE 中的序号存在的，那么我们称这种字符串为 UNICODE 字符串或者宽字节字符串。 L\"中文123\" （占10字节） 1、什么是字符集 在介绍字符集之前，我们先了解下为什么要有字符集。 我们在计算机屏幕上看到的是实体化的文字，而在计算机存储介质中存放的实际是二进制的比特流。 那么在这两者之间的转换规则就需要一个统一的标准，为了实现转换标准，各种字符集标准就出现了。 简单的说字符集就是规定了某个文字对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个文字（解码）的转换关系。 那么为什么会有那么多字符集标准呢？ 很多规范和标准在最初制定时并不会意识到这将会是以后全球普适的准则，或者处于组织本身利益就想从本质上区别于现有标准。 于是，就产生了那么多具有相同效果但又不相互兼容的标准了。 说了那么多我们来看一个实际例子，下面就是屌这个字在各种编码下的十六进制和二进制编码结果，怎么样有没有一种很屌的感觉？ 字符集 16进制编码 对应的二进制数据 UTF-8 0xE5B18C 1110 0101 1011 0001 1000 1100 UTF-16 0x5C4C 1011 1000 1001 1000 GBK 0x8CC5 1000 1100 1100 0101 字符集：文字编码解码关系的定义，英语这种字符中的 water 和汉语这种字符中的水是指同一个东西。 2、什么是字符编码 字符集只是一个规则集合的名字，对应到真实生活中，字符集就是对某种语言的称呼。例如：英语，汉语，日语。 规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“字符编码”。 3、ASCII 码 我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。 也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。 4、非ASCII 码 英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。 比如在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。 比如130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。 但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。 至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 5、Unicode 正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。 因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。 为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。 可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。 Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。 6、Unicode 的问题 需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题： 第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？ 第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 它们造成的结果是： 1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。 2）Unicode 在很长一段时间内无法推广，直到互联网的出现。 7、UTF-8 互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。 其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。 重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。 UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母x表示可用编码的位。 Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制） ----------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。 如果一个字节的第一位是0，则这个字节单独就是一个字符； 如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。 下面，还是以汉字严为例，演示如何实现 UTF-8 编码。 严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。 Unicode就是上文中提到的字符集，而UTF-8就是字符编码，即Unicode规则字库的一种实现形式。 二、容易产生的误解 对编码的误解 误解一 在将“字节串”转化成“UNICODE 字符串”时，比如在读取文本文件时，或者通过网络传输文本时，容易将“字节串”简单地作为单字节字符串，采用每“一个字节”就是“一个字符”的方法进行转化。 而实际上，在非英文的环境中，应该将“字节串”作为 ANSI 字符串，采用适当的编码来得到 UNICODE 字符串，有可能“多个字节”才能得到“一个字符”。 通常，一直在英文环境下做开发的程序员们，容易有这种误解。 误解二 在 DOS，Windows 98 等非 UNICODE 环境下，字符串都是以 ANSI 编码的字节形式存在的。这种以字节形式存在的字符串，必须知道是哪种编码才能被正确地使用。这使我们形成了一个惯性思维：“字符串的编码”。 当 UNICODE 被支持后，Java 中的 String 是以字符的“序号”来存储的，不是以“某种编码的字节”来存储的，因此已经不存在“字符串的编码”这个概念了。只有在“字符串”与“字节串”转化时，或者，将一个“字节串”当成一个 ANSI 字符串时，才有编码的概念。 不少的人都有这个误解。 第一种误解，往往是导致乱码产生的原因。第二种误解，往往导致本来容易纠正的乱码问题变得更复杂。 在这里，我们可以看到，其中所讲的“误解一”，即采用每“一个字节”就是“一个字符”的转化方法，实际上也就等同于采用 iso-8859-1 进行转化。因此，我们常常使用 bytes = string.getBytes(\"iso-8859-1\") 来进行逆向操作，得到原始的“字节串”。然后再使用正确的 ANSI 编码，比如 string = new String(bytes, \"GB2312\")，来得到正确的“UNICODE 字符串”。 三、乱码产生的原因和解决办法 简单的说乱码的出现是因为：编码和解码时用了不同或者不兼容的字符集。 要从乱码字符中反解出原来的正确文字需要对各个字符集编码规则有较为深刻的掌握。但是原理很简单，这里用最常见的UTF-8被错误用GBK展示时的乱码为例，来说明具体反解和识别过程。 第1步 编码 假设我们在页面上看到寰堝睂这样的乱码，而又得知我们的浏览器当前使用GBK编码。那么第一步我们就能先通过GBK把乱码编码成二进制表达式。当然查表编码效率很低，我们也可以用以下SQL语句直接通过MySQL客户端来做编码工作： mysql [localhost] {msandbox} > select hex(convert('寰堝睂' using gbk)); +-------------------------------------+ | hex(convert('寰堝睂' using gbk)) | +-------------------------------------+ | E5BE88E5B18C | +-------------------------------------+ 1 row in set (0.01 sec) 第2步 识别 现在我们得到了解码后的二进制字符串E5BE88E5B18C。然后我们将它按字节拆开。 Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 E5 BE 88 E5 B1 8C 第3步 解码 然后我们就能拿着E5BE88E5B18C用UTF-8解码，查看乱码前的文字了。当然我们可以不查表直接通过SQL获得结果： mysql [localhost] {msandbox} ((none)) > select convert(0xE5BE88E5B18C using utf8); +------------------------------------+ | convert(0xE5BE88E5B18C using utf8) | +------------------------------------+ | 很屌 | +------------------------------------+ 1 row in set (0.00 sec) 四、字符编码工作方式 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件： 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器： 所以你看到很多网页的源码上会有类似的信息，表示该网页正是用的UTF-8编码。 五、常见问题处理之Emoji 所谓Emoji就是一种在Unicode位于\\u1F601-\\u1F64F区段的字符。这个显然超过了目前常用的UTF-8字符集的编码范围\\u0000-\\uFFFF。Emoji表情随着IOS的普及和微信的支持越来越常见。 下面就是几个常见的Emoji: 那么Emoji字符表情会对我们平时的开发运维带来什么影响呢？ 最常见的问题就在于将他存入MySQL数据库的时候。一般来说MySQL数据库的默认字符集都会配置成UTF-8（三字节），而utf8mb4在5.5以后才被支持，也很少会有DBA主动将系统默认字符集改成utf8mb4。 那么问题就来了，当我们把一个需要4字节UTF-8编码才能表示的字符存入数据库的时候就会报错：ERROR 1366: Incorrect string value: '\\xF0\\x9D\\x8C\\x86' for column 。 如果认真阅读了上面的解释，那么这个报错也就不难看懂了。我们试图将一串Bytes插入到一列中，而这串Bytes的第一个字节是\\xF0意味着这是一个四字节的UTF-8编码。 但是当MySQL表和列字符集配置为UTF-8的时候是无法存储这样的字符的，所以报了错。 那么遇到这种情况我们如何解决呢？ 有两种方式：升级MySQL到5.6或更高版本，并且将表字符集切换至utf8mb4。 第二种方法就是在把内容存入到数据库之前做一次过滤，将Emoji字符替换成一段特殊的文字编码，然后再存入数据库中。 之后从数据库获取或者前端展示时再将这段特殊文字编码转换成Emoji显示。 第二种方法我们假设用-*-1F601-*-来替代4字节的Emoji，那么具体实现python代码可以参见Stackoverflow上的回答 powered by Gitbook该文章修订时间： 2021-02-25 10:44:39 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"base/linux-base/02-Linux中的系统负载.html":{"url":"base/linux-base/02-Linux中的系统负载.html","title":"02-Linux中的CPU负载","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 一、负载的查看方式 二、多核心处理器与多处理器的区别 三、对负载的理解 CPU核心 进程状态 sleep进程 平均负载与CPU使用率 四、CPU使用率低负载高的原因分析 什么是负载 CPU负载 IO负载 什么是多任务操作系统 什么是进程调度 五、负载分析工具 六、CPU过高排查思路 1、定位到占用CPU高的进程 2、查看进程中的线程CPU情况 3、线程ID转换为十六进制 4、从堆栈定位代码块 一、负载的查看方式 w/uptime/top # 都是读取的 /proc/loadavg 这个文件 load average: 0.00, 0.01, 0.05 意思分别是1分钟、5分钟、15分钟内系统的平均负载 二、多核心处理器与多处理器的区别 从性能的角度上理解，一台主机拥有多核心的处理器与另台拥有同样数目的处理性能基本上可以认为是相差无几。 当然实际情况会复杂得多，不同数量的缓存、处理器的频率等因素都可能造成性能的差异。 但即便这些因素造成的实际性能稍有不同，其实系统还是以处理器的核心数量计算负载均值。 三、对负载的理解 CPU核心 如果系统中有N个核心，那么负载为N的时候，就意味着 CPU 在全力运转。 # 查看 CPU 的核心数 grep -c 'model name' /proc/CPUinfo 当系统负荷持续大于0.7N，你必须开始调查了，问题出在哪里，防止情况恶化。 当系统负荷持续大于1.0N，你必须动手寻找解决办法，把这个值降下来。 当系统负荷达到5.0N，就表明你的系统有很严重的问题，长时间没有响应，或者接近死机了，你不应该让系统达到这个值。 如果只有1分钟的系统负荷大于1.0，其他两个时间段都小于1.0，这表明只是暂时现象，问题不大。 如果15分钟内，平均系统负荷大于1.0（调整CPU核心数之后），表明问题持续存在，不是暂时现象。 所以，你应该主要观察\"15分钟系统负荷\"，将它作为电脑正常运行的指标。 进程状态 在Linux中，进程分为三种状态： 阻塞的进程 blocked process，进程会等待I/O设备的数据或者系统调用。 正在等待可运行的进程 runnable process，处在一个运行队列run queue中，与其他可运行进程争夺CPU时间。 正在运行的进程running process 系统的load是指正在运行running one和可运行runnable one的进程的总数。 比如现在系统有2个正在运行的进程，3个可运行进程，那么系统的load就是5，load average就是一定时间内的load数量。 在linux内核中无法区别正在运行的状态和可运行的等待状态，所以都称为running状态。 sleep进程 Linux上的load average除了包括正在运行CPU的进程数量和正在等待可运行CPU的进程数量之外，还包括uninterruptible sleep的进程数量。 通常等待IO设备、等待网络的时候，进程会处于uninterruptible sleep状态。 Linux设计者的逻辑是，uninterruptible sleep应该都是很短暂的，很快就会恢复运行，所以被等同于runnable。 然而uninterruptible sleep即使再短暂也是sleep，何况现实世界中uninterruptible sleep未必很短暂，大量的、或长时间的uninterruptible sleep通常意味着IO设备遇到了瓶颈。 众所周知，sleep状态的进程是不需要CPU的，即使所有的CPU都空闲，正在sleep的进程也是运行不了的。 所以sleep进程的数量绝对不适合用作衡量CPU负载的指标，Linux把uninterruptible sleep进程算进load average的做法直接颠覆了load average的本来意义。 所以在Linux系统上，load average这个指标基本失去了作用，因为你不知道它代表什么意思，当看到load average很高的时候，你不知道是runnable进程太多还是uninterruptible sleep进程太多，也就无法判断是CPU不够用还是IO设备有瓶颈。 平均负载与CPU使用率 平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数，所以，他不仅包扩了正在使用CPU的进程，还包括等待CPU和等待I/O的进程。 而CPU使用率，是单位时间内CPU繁忙情况的统计，和平均负载并不一定完全对应。 CPU密集型进程，使用大量CPU会导致平均负载升高，此时这两者是一致的。 I/O 密集型进程， 等待I/O也会导致平均负载升高，但是CPU使用率不一定很高。 大量等待CPU的进程调用也会导致平均负载升高，此时的CPU使用率也会比较高。 如果把系统负载比作一条高速公路，进程比作车，CPU使用率高只能说车跑的快，和高速公路是否拥挤（负载是否过高）没有关系。 四、CPU使用率低负载高的原因分析 一句话总结就是：等待磁盘I/O完成的进程过多，导致进程队列长度过大，但是CPU运行的进程却很少。 什么是负载 负载就是CPU在一段时间内正在处理以及等待CPU处理的进程数之和的统计信息，也就是CPU使用队列的长度统计信息，这个数字越小越好如果超过CPU核心*0.7系统就会不稳定。 负载分为两大部分： CPU负载 例如，假设有一个进行大规模科学计算的程序，虽然该程序不会频繁地从磁盘输入输出，但是处理完成需要相当长的时间。 因为该程序主要被用来做计算、逻辑判断等处理，所以程序的处理速度主要依赖于CPU的计算速度。 此类CPU负载的程序称为“计算密集型程序”。 IO负载 还有一类程序，主要从磁盘保存的大量数据中搜索找出任意文件。这个搜索程序的处理速度并不依赖于CPU，而是依赖于磁盘的读取速度，也就是输入输出input/output,I/O.磁盘越快，检索花费的时间就越短。此类I/O负载的程序，称为“I/O密集型程序”。 什么是多任务操作系统 Linux操作系统能够同时处理几个不同名称的任务。但是同时运行多个任务的过程中，CPU和磁盘这些有限的硬件资源就需要被这些任务程序共享。即便很短的时间间隔内，需要一边在这些任务之间进行切换到一边进行处理，这就是多任务。 运行中的任务较少的情况下，系统并不是等待此类切换动作的发生。但是当任务增加时，例如任务A正在CPU上执行计算，接下来如果任务B和C也想进行计算，那么就需要等待CPU空闲。也就是说，即便是运行处理某任务，也要等到轮到他时才能运行，此类等待状态就表现为程序运行延迟。 什么是进程调度 进程调度也被一些人称为CPU上下文切换意思是：CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态：当前运行任务转为就绪或者挂起、中断状态，另一个被选定的就绪任务成为当前任务。 进程调度包括保存当前任务的运行环境，恢复将要运行任务的运行环境。 在linux内核中，每一个进程都存在一个名为“进程描述符”的管理表。 该进程描述符会调整为按照优先级降序排序，已按合理的顺序运行进程任务。这个调整即为进程调度器的工作。 进程的状态区别: 状态 说明 运行态running 只要CPU空闲，任何时候都可以运行 可中断睡眠interruptible 为恢复时间无法预测的长时间等待状态。如，来自于键盘设备的输入。 不可中断睡眠:uninterruptible 主要为短时间时的等待状态。例如磁盘输入输出等待。被IO阻塞的进程。 就绪态runnable 响应暂停信号而运行的中断状态。 僵死态zombie 进程由父进程创建并销毁；在父进程中没有销毁子进程被销毁的时候，子进程就会转变为僵死态。 CPU低而负载高也就是说等待磁盘I/O完成的进程过多，就会导致队列长度过大，这样就体现到负载过大了，但实际是此时CPU被分配去执行别的任务或空闲，具体场景有如下几种。 场景一：磁盘读写请求过多就会导致大量I/O等待 CPU的工作效率要高于磁盘，而进程在CPU上面运行需要访问磁盘文件，这个时候CPU会向内核发起调用文件的请求，让内核去磁盘取文件，这个时候会切换到其他进程或者空闲，这个任务就会转换为不可中断睡眠状态。当这种读写请求过多就会导致不可中断睡眠状态的进程过多，从而导致负载高，CPU低的情况。 场景二：MySQL中存在没有索引的语句或存在死锁等情况 我们都知道MySQL的数据是存储在硬盘中，如果需要进行sql查询，需要先把数据从磁盘加载到内存中。 当在数据特别大的时候，如果执行的sql语句没有索引，就会造成扫描表的行数过大导致I/O阻塞，或者是语句中存在死锁，也会造成I/O阻塞，从而导致不可中断睡眠进程过多，导致负载过大。具体解决方法可以在MySQL中运行show full processlist命令查看线程等待情况，把其中的语句拿出来进行优化。 场景三：外接存储故障，常见有挂了NFS，但是NFS server故障 比如系统挂载了外接硬盘如NFS共享存储，经常会有大量的读写请求去访问NFS存储的文件，如果这个时候NFS服务器故障，那么就会导致进程读写请求一直获取不到资源，从而进程一直是不可中断状态，造成负载很高。 五、负载分析工具 这里会用到2个工具，stress和sysstat stress是一个Linux系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。 sysstat是一个linux性能工具，用来监控和分析系统的性能，以下案例中会用到这个包的2个命令mpstat和pidstat。 mpstat 是一个常用的多核CPU性能分析工具用来实时查看每个CPU的性能指标，一级所有CPI的平均指标。 pidstat 是一个常用的进程性能分析工具，用来实时查看进程的CPU、内存、I/O以及上下文切换等性能指标。 # CPU 一个核心满载运行 600s stress --cpu 1 --timeout 600 # 查看 CPU 各个核心的负载情况，每隔 5s 刷新一次 mpstat -P ALL 5 # 报告 CPU 利用率，间隔 5s ，展示 1 次 pidstat -u 5 1 # 模拟IO负荷 stress -i 1 --timeout 600 六、CPU过高排查思路 1、定位到占用CPU高的进程 top (SHIFT + P 按 CPU 使用率排序) 2、查看进程中的线程CPU情况 top -Hp $进程ID # 找到CPU高的线程 $thread_id 3、线程ID转换为十六进制 printf \"%x\\n\" $thread_id 4、从堆栈定位代码块 jstack $进程ID |grep $十六进制 -A 30 powered by Gitbook该文章修订时间： 2021-02-25 15:40:28 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"safe/ssl/01-ssl介绍.html":{"url":"safe/ssl/01-ssl介绍.html","title":"SSL","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 介绍 名称解释 基础命令 关于证书签名请求（CSR） 生成CSR 生成私钥和CSR 从现有的私钥生成CSR 从现有证书和私钥生成CSR 生成SSL证书 生成自签名证书 从现有的私钥生成自签名证书 从现有的私钥和CSR生成自签名证书 查看证书 查看CSR条目 查看证书条目 验证CA签署的证书 私钥 创建私钥 验证私钥 验证私钥匹配证书和CSR 加密私钥 解密私钥 转换证书格式 将PEM转换为DER 将DER转换为PEM 将PEM转换为PKCS7 将PKCS7转换为PEM 将PEM转换为PKCS12 将PKCS12转换为PEM OpenSSL版本 介绍 OpenSSL是一个多功能的命令行工具，可用于与公钥基础设施（PKI）和HTTPS（HTTP over TLS）相关的大量任务。 这个cheat sheet样式指南提供了对常用的日常场景中有用的OpenSSL命令的快速参考。 这包括生成私钥，证书签名请求和证书格式转换的OpenSSL示例。 它不包括OpenSSL的所有使用。 名称解释 .key 通常用来存放一个RSA 公钥或者私钥,并非X.509证书,编码同样的,可能是PEM,也可能是DER。 CSR: 证书签名请求(Cerificate Signing Request) 这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息，如国家/地区/域名/邮件等),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好。申请证书的时候提供 CSR 内容，域名续期可以不更换CSR（当然私钥也不变）。 cer/crt 两个指的都是证书。 windows下叫cer，linux下叫crt； 存储格式可以为pem也可以为der .crt与.cer这两个扩展名其实与文件本身的编码方式无关，在文件编码方式不变的情况下，只需改个扩展名。 真正需要转换的是.pem与.der这两种证书文件，因为他们使用不同的编码方式。 X.509：数字证书的一种标准 X.509的证书文件，一般以 .cer 或 .crt 结尾，根据该文件的内容编码格式，可以分为二种格式： PEM -BASE64编码 ，Apache和Nginx 服务器偏向于使用这种编码格式 .cert 和 .key DER - 二进制格式,不可读，Java和Windows服务器偏向于使用这种编码格式 PKI（Public Key Infrastructure） 公钥基础设施，全面解决安全问题的基础结构 CA （certificate authority) 证书认证中心，是负责发放和管理证书的第三方权威机构。 SSL 我有一个箱子，一把锁和一把钥匙，我把箱子和开着的锁给别人，他写了信放箱子里，锁上，然后传递回我手上的途中谁都是打不开箱子的，只有我可以用原来的钥匙打开，这就是SSL，公钥，私钥传递加密消息的方式。这里的密钥就是key文件。 基础命令 # 查看网站证书有效期 echo | openssl s_client -servername dev.cloud.tencent.com -connect dev.cloud.tencent.com:443 2>/dev/null | openssl x509 -noout -dates # 拼接 fullchain cat web.cer middle.cer ca.cer > fullchain.cer # 查看网站证书内容 openssl s_client -connect coding.net:443 -showcerts # 生成私钥和 CSR openssl req -new -sha256 -newkey rsa:2048 -nodes -subj '/C=CN/ST=Guangdong/L=Shenzhen/O=Coding.net/CN=*.coding.net' -keyout coding.net.pem -out coding_net.csr # 查看 CSR openssl req -text -in $filename.csr # PEM 格式转换为 DER 格式 openssl req -in example_csr.pem -out example_csr.der -outform DER # DER 格式转换为 PEM 格式 openssl req -in example_csr.der -inform DER -out example_csr.pem -outform PEM # 查看证书有效期 openssl x509 -in xxxx.pem -noout -dates # 生成私钥 openssl genrsa -out rsa_private_key.pem 2048 # 从现有私钥生成新的 CSR openssl req -key domain.key -new -out domain.csr # 根据私钥生成公钥 openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem # 从现有私钥生成自签名证书（如果不需要第三方授权，或者是要创建一个用于测试的授权，就可以这样操作） openssl req -new -x509 -key privkey.pem -out cacert.pem -days 365 # 从现有证书和私钥中提取 CSR（续订现有证书，但因某种原因没有原始的CSR） openssl x509 -in enterprise.pem -signkey enterprise.key -x509toreq -out enterprise.csr # 从现有的私钥和CSR生成证书 openssl x509 -signkey enterprise.key -in enterprise.csr -req -days 365 -out enterprise.pem 关于证书签名请求（CSR） 如果要从证书颁发机构（CA）获取SSL证书，则必须生成证书签名请求（CSR）。 CSR主要由密钥对的公钥和一些附加信息组成。 这两个组件在签名时插入到证书中。 无论何时生成CSR，系统都会提示您提供有关证书的信息。 此信息称为识别名称（DN）。 在DN的一个重要领域是通用名称 （CN），这应该是您要使用的证书的主机的确切完全限定域名（FQDN）。 通过经由命令行或从文件传递信息来创建CSR时，也可以跳过交互式提示。 DN中的其他项目提供有关您的业务或组织的其他信息。 如果您从证书颁发机构购买SSL证书，则通常需要这些附加字段（例如“组织”）准确反映您组织的详细信息。 以下是CSR信息提示的外观示例： --- Country Name (2 letter code) [AU]:US State or Province Name (full name) [Some-State]:New York Locality Name (eg, city) []:Brooklyn Organization Name (eg, company) [Internet Widgits Pty Ltd]:Example Brooklyn Company Organizational Unit Name (eg, section) []:Technology Division Common Name (e.g. server FQDN or YOUR name) []:examplebrooklyn.com Email Address []: 如果你想以非交互回答CSR信息提示，你可以这样做通过添加-subj选项任何OpenSSL的命令，要求企业社会责任的信息。 下面是一个使用上面代码块中显示的相同信息的选项示例： -subj \"/C=US/ST=New York/L=Brooklyn/O=Example Brooklyn Company/CN=examplebrooklyn.com\" 现在您已经了解了CSR，请随时跳到本指南中涵盖OpenSSL需求的部分。 生成CSR 本节涵盖与生成CSR相关的OpenSSL命令（以及私钥，如果它们尚不存在）。 CSR可用于从证书颁发机构请求SSL证书。 请记住，您可以用非交互添加CSR信息-subj选项，在上一节中提到。 生成私钥和CSR 如果要使用HTTPS（HTTP over TLS）来保护Apache HTTP或Nginx Web服务器，并且希望使用证书颁发机构（CA）颁发SSL证书，请使用此方法。 生成的CSR可以发送到CA，以请求签发CA签署的SSL证书。 如果您的CA支持SHA-2，添加-sha256选项和SHA-2签署CSR。 此命令创建一个2048位密钥（ domain.key ）和CSR（ domain.csr从头开始）： openssl req \\ -newkey rsa:2048 -nodes -keyout domain.key \\ -out domain.csr 回答CSR信息提示以完成该过程。 该-newkey rsa:2048选项指定的关键应该是2048位，使用RSA算法生成的。 该-nodes选项指定私钥不应该密码短语进行加密。 该-new选项，这里没有包括在内，但暗示，表示正在生成CSR。 从现有的私钥生成CSR 如果您已拥有要用于从CA请求证书的私钥，请使用此方法。 此命令创建一个新的CSR（ domain.csr基于现有的私有密钥() domain.key ）： openssl req \\ -key domain.key \\ -new -out domain.csr 回答CSR信息提示以完成该过程。 所述-key选项指定现有的私钥（ domain.key将用于生成一个新的CSR）。 该-new选项表示正在生成一个CSR。 从现有证书和私钥生成CSR 如果您要续订现有证书，但是您或您的CA因某种原因没有原始的CSR，请使用此方法。 它基本上可以节省您重新输入CSR信息的麻烦，因为它从现有证书中提取信息。 此命令创建一个新的CSR（ domain.csr基于现有证书() domain.crt ）和私钥（ domain.key ）： openssl x509 \\ -in domain.crt \\ -signkey domain.key \\ -x509toreq -out domain.csr 该-x509toreq选项指定使用的X509证书，使企业社会责任。 生成SSL证书 如果要使用SSL证书来保护服务，但不需要CA签发的证书，则有效（免费）解决方案是签署您自己的证书。 证书可以发出自己的一种常见类型是自签名证书 。 自签名证书是使用其自己的私钥签名的证书。 自签名证书可用于加密数据以及CA签名的证书，但您的用户将显示一条警告，表示证书不受其计算机或浏览器信任。 因此，只有在您不需要向其用户（例如非生产或非公用服务器）证明您的服务的身份时，才应使用自签名证书。 本节包括与生成自签名证书相关的OpenSSL命令。 生成自签名证书 如果要使用HTTPS（HTTP over TLS）来保护Apache HTTP或Nginx Web服务器，并且不要求您的证书由CA签名，请使用此方法。 此命令创建一个2048位密钥（ domain.key ）和一个自签名证书（ domain.crt从头开始）： openssl req \\ -newkey rsa:2048 -nodes -keyout domain.key \\ -x509 -days 365 -out domain.crt 回答CSR信息提示以完成该过程。 该-x509选项告诉req创建一个自签署cerificate。 该-days 365选项指定证书的有效期为365天。 生成临时CSR以收集要与证书关联的信息。 从现有的私钥生成自签名证书 如果您已经有要使用它生成自签名证书的私钥，请使用此方法。 此命令创建一个自签名证书（ domain.crt从现有的私有密钥() domain.key ）： openssl req \\ -key domain.key \\ -new \\ -x509 -days 365 -out domain.crt 回答CSR信息提示以完成该过程。 该-x509选项告诉req创建一个自签署cerificate。 该-days 365选项指定证书的有效期为365天。 该-new选项使CSR信息提示。 从现有的私钥和CSR生成自签名证书 如果您已有私钥和CSR，并且希望使用它们生成自签名证书，请使用此方法。 此命令创建一个自签名证书（ domain.crt从现有的私有密钥() domain.key ）和（ domain.csr ）： openssl x509 \\ -signkey domain.key \\ -in domain.csr \\ -req -days 365 -out domain.crt 该-days 365选项指定证书的有效期为365天。 查看证书 证书和CSR文件以PEM格式编码，这不易于人类阅读。 本节介绍将输出PEM编码文件的实际条目的OpenSSL命令。 查看CSR条目 该命令允许您查看和验证CSR（内容domain.csr纯文本）： openssl req -text -noout -verify -in domain.csr 查看证书条目 此命令可以查看证书（内容domain.crt纯文本）： openssl x509 -text -noout -in domain.crt 验证CA签署的证书 使用此命令来验证证书（ domain.crt ）是由一个特定的CA证书（签署ca.crt ）： openssl verify -verbose -CAFile ca.crt domain.crt 私钥 本节包括专用于创建和验证私钥的OpenSSL命令。 创建私钥 使用此命令创建一个密码保护，2048位私钥（ domain.key ）： openssl genrsa -des3 -out domain.key 2048 系统提示完成此过程时输入密码。 验证私钥 使用此命令检查私钥（ domain.key ）是一个有效的关键： openssl rsa -check -in domain.key 如果您的私钥是加密的，将提示您输入其密码。 成功后，未加密的密钥将在终端上输出。 验证私钥匹配证书和CSR 使用这些命令来验证，如果私钥（ domain.key ）证书（符合domain.crt ）和CSR（ domain.csr ）： openssl rsa -noout -modulus -in domain.key | openssl md5 openssl x509 -noout -modulus -in domain.crt | openssl md5 openssl req -noout -modulus -in domain.csr | openssl md5 如果每个命令的输出相同，则私钥，证书和CSR相关的可能性极高。 加密私钥 这需要一个未加密的私钥（ unencrypted.key ），并输出它（的加密版本encrypted.key ）： openssl rsa -des3 \\ -in unencrypted.key \\ -out encrypted.key 输入您想要的密码短语，用加密私钥。 解密私钥 这需要一个加密私钥（ encrypted.key ），并输出它（解密版本decrypted.key ）： openssl rsa \\ -in encrypted.key \\ -out decrypted.key 出现提示时，输入加密密钥的密码短语。 转换证书格式 我们一直使用的所有证书都是ASCII PEM编码的X.509证书。 还有各种其他的证书编码和容器类型; 一些应用程序比其他应用程序更喜欢某些格式。 此外，许多这些格式可以在单个文件中包含多个项目，例如私钥，证书和CA证书。 OpenSSL可用于将证书转换为各种各样的格式。 本节将介绍一些可能的转化。 将PEM转换为DER 如果你想一个PEM编码的证书（转换使用此命令domain.crt ）到DER编码的证书（ domain.der ），二进制格式： openssl x509 \\ -in domain.crt \\ -outform der -out domain.der DER格式通常与Java一起使用。 将DER转换为PEM 如果你想要一个DER编码的证书（转换使用此命令domain.der ）到PEM编码的证书（ domain.crt ）： openssl x509 \\ -inform der -in domain.der \\ -out domain.crt 将PEM转换为PKCS7 如果你想PEM证书（添加使用此命令domain.crt和ca-chain.crt ）到PKCS7文件（ domain.p7b ）： openssl crl2pkcs7 -nocrl \\ -certfile domain.crt \\ -certfile ca-chain.crt \\ -out domain.p7b 请注意，您可以使用一个或多个-certfile选项来指定要添加到PKCS7文件，证书。 PKCS7文件（也称为P7B）通常用于Java密钥库和Microsoft IIS（Windows）中。 它们是ASCII文件，可以包含证书和CA证书。 将PKCS7转换为PEM 如果你想一个PKCS7文件（转换使用此命令domain.p7b ）到PEM文件： openssl pkcs7 \\ -in domain.p7b \\ -print_certs -out domain.crt 请注意，如果您的PKCS7文件中有多个项目（例如证书和CA中间证书），则创建的PEM文件将包含其中的所有项目。 将PEM转换为PKCS12 如果你想利用私钥（使用此命令domain.key ）和证书（ domain.crt ），并结合成一个PKCS12文件（ domain.pfx ）： openssl pkcs12 \\ -inkey domain.key \\ -in domain.crt \\ -export -out domain.pfx 系统将提示您输出导出密码，您可以留空。 请注意，您可以通过一个单一的PEM文件（串联证书加在一起的证书链到PKCS12文件domain.crt在这种情况下）。 PKCS12文件（也称为PFX文件）通常用于在Micrsoft IIS（Windows）中导入和导出证书链。 将PKCS12转换为PEM 如果你想转换一个PKCS12文件（使用此命令domain.pfx ），并将其转换为PEM格式（ domain.combined.crt ）： openssl pkcs12 \\ -in domain.pfx \\ -nodes -out domain.combined.crt 请注意，如果您的PKCS12文件中有多个项目（例如证书和私钥），则创建的PEM文件将包含其中的所有项目。 OpenSSL版本 该openssl version命令可以用来检查正在运行的版本。 您正在运行的OpenSSL版本及其编译的选项会影响您可用的功能（有时还包括命令行选项）。 以下命令显示您正在运行的OpenSSL版本及其编译时使用的所有选项： openssl version -a 本指南是使用具有以下详细信息（上一个命令的输出）的OpenSSL二进制文件编写的： OpenSSL 1.0.1f 6 Jan 2014 built on: Mon Apr 7 21:22:23 UTC 2014 platform: debian-amd64 options: bn(64,64) rc4(16x,int) des(idx,cisc,16,int) blowfish(idx) compiler: cc -fPIC -DOPENSSL_PIC -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -m64 -DL_ENDIAN -DTERMIO -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2 -Wl,-Bsymbolic-functions -Wl,-z,relro -Wa,--noexecstack -Wall -DMD32_REG_T=int -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM OPENSSLDIR: \"/usr/lib/ssl\" powered by Gitbook该文章修订时间： 2021-02-18 13:53:31 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}